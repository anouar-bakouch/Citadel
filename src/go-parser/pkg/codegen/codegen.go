package codegen

import (
	"fmt"
	"llvm-security-parser/pkg/parser"
	"strings"
)

type CodeGen struct {
output      strings.Builder
regCounter  int
labelCounter int
variables   map[string]int // maps var name to register number
}

func New() *CodeGen {
return &CodeGen{
variables: make(map[string]int),
regCounter: 1,
labelCounter: 1,
}
}

func (c *CodeGen) nextReg() int {
reg := c.regCounter
c.regCounter++
return reg
}

func (c *CodeGen) nextLabel() int {
label := c.labelCounter
c.labelCounter++
return label
}

func (c *CodeGen) Generate(program *parser.Program) (string, error) {
// Header
c.output.WriteString("; Generated by llvm-security-parser\n")
c.output.WriteString("target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n")
c.output.WriteString("target triple = \"x86_64-pc-linux-gnu\"\n\n")

// Generate each function
for _, fn := range program.Functions {
if err := c.generateFunction(fn); err != nil {
return "", err
}
}

return c.output.String(), nil
}

func (c *CodeGen) generateFunction(fn *parser.Function) error {
	// Function signature
	params := []string{}
	for _, param := range fn.Params {
		params = append(params, fmt.Sprintf("i32 %%%s", param.Name))
	}

	c.output.WriteString(fmt.Sprintf("define i32 @%s(%s) {\n", fn.Name, strings.Join(params, ", ")))

	// Reset counters for this function
	c.regCounter = 1
	c.labelCounter = 8 // Start labels at 8 to match clang output

	// Entry block - allocate space for return
	returnReg := c.nextReg() // %1 is typically the return value slot
	c.output.WriteString(fmt.Sprintf("  %%%d = alloca i32, align 4\n", returnReg))

	// Allocate space for parameters and store incoming args
	for _, param := range fn.Params {
		reg := c.nextReg()
		c.variables[param.Name] = reg
		c.output.WriteString(fmt.Sprintf("  %%%d = alloca i32, align 4\n", reg))
	}

	for _, param := range fn.Params {
		c.output.WriteString(fmt.Sprintf("  store i32 %%%s, i32* %%%d, align 4\n", param.Name, c.variables[param.Name]))
	}

// Generate body statements
if err := c.generateBlock(fn.Body, returnReg); err != nil {
return err
}

c.output.WriteString("}\n\n")
return nil
}

func (c *CodeGen) generateBlock(block *parser.Block, returnReg int) error {
for _, stmt := range block.Statements {
if err := c.generateStatement(stmt, returnReg); err != nil {
return err
}
}
return nil
}

func (c *CodeGen) generateStatement(stmt parser.Statement, returnReg int) error {
switch s := stmt.(type) {
case *parser.VarDecl:
return c.generateVarDecl(s)
case *parser.IfStatement:
return c.generateIfStatement(s, returnReg)
case *parser.ReturnStatement:
return c.generateReturnStatement(s, returnReg)
default:
return fmt.Errorf("unknown statement type")
}
}

func (c *CodeGen) generateVarDecl(decl *parser.VarDecl) error {
// Allocate space
reg := c.nextReg()
c.variables[decl.Name] = reg
c.output.WriteString(fmt.Sprintf("  %%%d = alloca i32, align 4\n", reg))

// Store initial value if provided
if decl.Value != nil {
		valueReg, err := c.generateExpression(decl.Value)
		if err != nil {
			return err
		}

		c.output.WriteString(fmt.Sprintf("  store i32 %%%d, i32* %%%d, align 4\n", valueReg, reg))
}

return nil
}

func (c *CodeGen) generateIfStatement(stmt *parser.IfStatement, returnReg int) error {
// Generate condition
condReg, err := c.generateExpression(stmt.Condition)
if err != nil {
return err
}

thenLabel := c.nextLabel()
elseLabel := c.nextLabel()

	c.output.WriteString(fmt.Sprintf("  br i1 %%%d, label %%%d, label %%%d\n\n", condReg, thenLabel, elseLabel))

	// Then block
	c.output.WriteString(fmt.Sprintf("%d:\n", thenLabel))
	if err := c.generateBlock(stmt.ThenBlock, returnReg); err != nil {
		return err
	}

	// Else block (or empty)
	c.output.WriteString(fmt.Sprintf("%d:\n", elseLabel))

return nil
}

func (c *CodeGen) generateReturnStatement(stmt *parser.ReturnStatement, returnReg int) error {
	// Evaluate return value
	valueReg, err := c.generateExpression(stmt.Value)
	if err != nil {
		return err
	}
	c.output.WriteString(fmt.Sprintf("  store i32 %%%d, i32* %%%d, align 4\n", valueReg, returnReg))

// Jump to final return block
finalLabel := c.nextLabel()
c.output.WriteString(fmt.Sprintf("  br label %%%d\n\n", finalLabel))

// Final return block
c.output.WriteString(fmt.Sprintf("%d:\n", finalLabel))
loadReg := c.nextReg()
c.output.WriteString(fmt.Sprintf("  %%%d = load i32, i32* %%%d, align 4\n", loadReg, returnReg))
c.output.WriteString(fmt.Sprintf("  ret i32 %%%d\n", loadReg))

return nil
}

func (c *CodeGen) generateExpression(expr parser.Expression) (int, error) {
switch e := expr.(type) {
case *parser.IntLiteral:
		// Materialize integer literal into a register
		reg := c.nextReg()
		c.output.WriteString(fmt.Sprintf("  %%%d = add i32 0, %d\n", reg, e.Value))
		return reg, nil
case *parser.Identifier:
// Load variable
varReg := c.variables[e.Name]
		if varReg == 0 {
			return 0, fmt.Errorf("undefined variable: %s", e.Name)
		}
		loadReg := c.nextReg()
		c.output.WriteString(fmt.Sprintf("  %%%d = load i32, i32* %%%d, align 4\n", loadReg, varReg))
		return loadReg, nil
case *parser.BinaryOp:
return c.generateBinaryOp(e)
default:
return 0, fmt.Errorf("unknown expression type")
}
}

func (c *CodeGen) generateBinaryOp(op *parser.BinaryOp) (int, error) {
leftReg, err := c.generateExpression(op.Left)
if err != nil {
return 0, err
}

rightReg, err := c.generateExpression(op.Right)
if err != nil {
return 0, err
}

resultReg := c.nextReg()

switch op.Operator {
case "==":
c.output.WriteString(fmt.Sprintf("  %%%d = icmp eq i32 %%%d, %%%d\n", resultReg, leftReg, rightReg))
case ">":
c.output.WriteString(fmt.Sprintf("  %%%d = icmp sgt i32 %%%d, %%%d\n", resultReg, leftReg, rightReg))
case "<":
c.output.WriteString(fmt.Sprintf("  %%%d = icmp slt i32 %%%d, %%%d\n", resultReg, leftReg, rightReg))
case "+":
c.output.WriteString(fmt.Sprintf("  %%%d = add i32 %%%d, %%%d\n", resultReg, leftReg, rightReg))
default:
return 0, fmt.Errorf("unsupported operator: %s", op.Operator)
}

return resultReg, nil
}
